# Рекурсия
# Рекурсия — это функция, вызывающая сама себя.

# С рекурсией Вы знакомы с C#, в Python она ничем не отличается, давай рассмотрим
# следующую задачу: Пользователь вводит число n. Необходимо вывести n - первых
# членов последовательности Фибоначчи.
# Напоминание: Последовательно Фибоначчи, это такая последовательность, в
# которой каждое последующее число равно сумму 2-ух предыдущих.

# При описании рекурсии важно указать, когда функции надо остановиться и
# перестать вызывать саму себя. По-другому говоря, необходимо указать базис
# рекурсии

# 0 1 1 2 3 5 8 13 21 34 55 89

def fib(n):
    if n - 2 < 1: # Граничный случай (Базис обязательно указывать!)
        return 1
    return fib(n - 1) + fib(n - 2) # Рекурсивный случай (То что мы будим делать при вызове функции)

print(fib(7))

list_1 =[]
for i in range(1, 10):
    list_1.append(fib(i)) # Добавляем в конец списока list_1 число получившееся при выполнении функции fib(i)

print(list_1)


#############################################
# Работа стека! 
stack = []
for i in range(1, 11):
    stack.append(f'{i}-й элемент')
    print(f'+ {i}-й элемент добавлен')
    for i in stack:
        print(i, end=" ")
print('\n')   

for i in range(len(stack)):
    print('В стеке: ', end=" ")
    for i in stack:
        print(i, end=" ")
    print(f'\n{stack.pop()} удален из стека')
#############################################



# Чтобы стек вызовов не переполнялся, в каждой рекурсивной функции всегда должны быть предусмотрены два случая:

# Граничный, при котором функция завершает работу и возвращает данные в основную программу.
# Рекурсивный, при котором функция продолжает вызывать себя.
# Вот пример простейшей рекурсивной функции, в которой учтены оба случая:

def greetings(st):
     print(st)
     if len(st) == 0:  # Граничный случай
         return             
     else:       # Рекурсивный случай
         greetings(st[:-1])   

greetings('Hello, world!')


####### ПРИМЕР #######
# Скорость выполнения: итерация vs рекурсия
# Рекурсивные функции работают медленнее обычных, поэтому их стоит применять только тогда, 
# когда решить задачу без рекурсии сложно. Вот сравнение времени выполнения двух функций, 
# рекурсивной fib_recursive(n) и обычной fib_iter(n), решающих одну и ту же задачу – вычисление последовательности Фибоначчи:


from timeit import timeit

def fib_iter(n):
    if n == 1:
        return [1]
    if n == 2:
        return [1, 1]
    fibs = [1, 1]
    for _ in range(2, n):
        fibs.append(fibs[-1] + fibs[-2])
    return fibs

setup_code_iter = 'from __main__ import fib_iter'
stmt_iter = 'fib_iter(15)'
print('Время выполнения итеративной функции: ', timeit(setup=setup_code_iter, stmt=stmt_iter, number=20000))

def fib_recursive(n):
    if(n <= 1):
        return n
    else:
        return(fib_recursive(n-1) + fib_recursive(n-2))
    
setup_code_rec = 'from __main__ import fib_recursive'
stmt_rec = 'fib_recursive(15)'
print('Время выполнения рекурсивной функции: ', timeit(setup=setup_code_rec, stmt=stmt_rec, number=20000))